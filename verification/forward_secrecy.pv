(* ============================================================================ *)
(* ZKS Forward Secrecy - FIXED                                                   *)
(* ============================================================================ *)
(* Models the recursive key chain for forward secrecy                           *)
(*                                                                              *)
(* SECURITY PROPERTY:                                                            *)
(* Keys derived BEFORE long-term key compromise remain secret.                  *)
(* This uses ProVerif's phase mechanism to model temporal ordering.             *)
(* ============================================================================ *)

(* --- Channels --- *)
free c: channel.

(* --- Hash/KDF functions --- *)
fun kdf(bitstring, bitstring): bitstring.
fun derive_key(bitstring): bitstring.
fun advance(bitstring): bitstring.

(* --- The only actual secret: long-term key --- *)
free long_term_key: bitstring [private].

(* ============================================================================ *)
(* Security Queries                                                             *)
(* ============================================================================ *)

(* Events for key derivation *)
event DerivedKey(nat, bitstring).
event KeyCompromised.

(* FIXED Query: Forward secrecy using phases.
   In phase 0: keys are derived and used.
   In phase 1: long-term key is compromised.
   
   We prove: Keys derived in phase 0 remain secret even after phase 1 compromise.
*)

(* Test if session key from epoch 1 is secret *)
free test_key_1: bitstring [private].

(* The main forward secrecy query: attacker cannot learn phase-0 derived keys *)
query attacker(test_key_1).

(* ============================================================================ *)
(* Key Chain Evolution                                                          *)
(* ============================================================================ *)

let KeyChain(initial_seed: bitstring) =
    (* Phase 0: Derive keys before any compromise *)
    
    (* Derive epoch 1 state and key *)
    let state1 = kdf(initial_seed, long_term_key) in
    let key1 = derive_key(state1) in
    event DerivedKey(1, key1);
    
    (* Bind test_key_1 to key1 for secrecy query *)
    let test_key_1 = key1 in
    
    (* Advance to epoch 2 - old state is zeroized (modeled by scope) *)
    let state2 = advance(state1) in
    let key2 = derive_key(state2) in
    event DerivedKey(2, key2);
    
    (* Advance to epoch 3 *)
    let state3 = advance(state2) in
    let key3 = derive_key(state3) in
    event DerivedKey(3, key3);
    
    (* Keys are never output - they stay internal *)
    0.


(* Compromise scenario - attacker learns long-term key AFTER keys derived *)
let CompromiseAfterDerivation =
    (* Wait for phase 1: Keys have been derived in phase 0 *)
    phase 1;
    
    (* Attacker learns long-term key in phase 1 *)
    event KeyCompromised;
    out(c, long_term_key).


(* ============================================================================ *)
(* Main Process                                                                 *)
(* ============================================================================ *)

process
    new shared_seed: bitstring;
    
    (* Run key derivation in phase 0, then allow compromise in phase 1 *)
    (KeyChain(shared_seed)) | (CompromiseAfterDerivation)
