(* ZKS Protocol - CryptoVerif Model with Authentication *)
(* Proves both secrecy and authentication using pq.ocvl *)

proof {
  crypto uf_cma(sign) rkB;
  auto
}

set backtrackOnCrypto = true.

param NA, NB, NK [small].

type host [bounded].
type keyseed [large, fixed].
type pkey [bounded].
type skey [bounded].
type blocksize [bounded].
type signature [bounded].
type nonce [large, fixed].
type prfkey [large, fixed].
type sessionkey [fixed].

(* KEM types *)
type kemkeyseed [large, fixed].
type kempk [bounded].
type kemsk [bounded].
type kemsec [fixed].
type kemct [bounded].
type kemoutput [bounded].

(* Signatures - UF-CMA *)
proba Psign.
proba Psigncoll.
expand UF_CMA_det_signature(keyseed, pkey, skey, blocksize, signature, skgen, pkgen, sign, check, Psign, Psigncoll).

(* ML-KEM - IND-CCA2 *)
proba Pkem.
proba Pkemkeycoll.
proba Pkemctcoll.
expand IND_CCA2_KEM(kemkeyseed, kempk, kemsk, kemsec, kemct, kemoutput, kempkgen, kemskgen, kemencap, kempair, kemdecap, keminjbot, Pkem, Pkemkeycoll, Pkemctcoll).

(* PRF *)
proba Pprf.
expand PRF_1(prfkey, bitstring, sessionkey, prf, Pprf).

(* Helper functions *)
fun concat_msg(host, host, kemct, nonce): blocksize [data].
fun concat_kdf(kemsec, nonce, nonce): bitstring [data].

(* Peers *)
const A, B: host.

(* Queries - Secrecy *)
query secret keyA.
query secret keyB.

(* Authentication events - bind to signed message content *)
event beginResp(blocksize).
event endInit(blocksize).

(* Authentication query - verifies signature authenticity *)
query m: blocksize;
  inj-event(endInit(m)) ==> inj-event(beginResp(m))
  public_vars keyA, keyB.

(* Initiator - Alice *)
let Initiator(pk: prfkey, pkB: pkey) =
  foreach iA <= NA do
  OA1(hostB: host) :=
    kemks <-R kemkeyseed;
    let kemsk_A: kemsk = kemskgen(kemks) in
    let kempk_A: kempk = kempkgen(kemks) in
    nA <-R nonce;
    return(A, hostB, kempk_A, nA);
  OA2(=A, =hostB, ct: kemct, nB: nonce, s: signature, pkResp: pkey) :=
    if pkResp = pkB then
    let msg: blocksize = concat_msg(A, hostB, ct, nB) in
    if check(msg, pkB, s) then
    let keminjbot(kem_secret: kemsec) = kemdecap(ct, kemsk_A) in
    let kA: sessionkey = prf(pk, concat_kdf(kem_secret, nA, nB)) in
    event endInit(msg);
    if hostB = B then
      let keyA: sessionkey = kA.

(* Responder - Bob *)
let Responder(pk: prfkey, skB: skey, pkB: pkey) =
  foreach iB <= NB do
  OB1(hostA: host, =B, kempk_i: kempk, nA: nonce) :=
    nB <-R nonce;
    let kempair(kem_secret: kemsec, ct: kemct) = kemencap(kempk_i) in
    let msg: blocksize = concat_msg(hostA, B, ct, nB) in
    let sig: signature = sign(msg, skB) in
    let kB: sessionkey = prf(pk, concat_kdf(kem_secret, nA, nB)) in
    event beginResp(msg);
    return(hostA, B, ct, nB, sig, pkB);
  OB2() :=
    if hostA = A then
      let keyB: sessionkey = kB.

process
  Ostart() :=
    pk <-R prfkey;
    rkB <-R keyseed;
    let skB: skey = skgen(rkB) in
    let pkB: pkey = pkgen(rkB) in
    return(pkB);
    (run Initiator(pk, pkB) | run Responder(pk, skB, pkB))
